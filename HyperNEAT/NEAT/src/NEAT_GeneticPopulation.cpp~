#include "NEAT_GeneticPopulation.h"

#include "NEAT_GeneticGeneration.h"



#include "NEAT_GeneticIndividual.h"
#include "NEAT_Random.h"
#include <algorithm>

#include <fstream>
#include <iostream>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/gzip.hpp>


namespace NEAT
{

    GeneticPopulation::GeneticPopulation()
            : onGeneration(0)
    {

        {
            generations.push_back(
                shared_ptr<GeneticGeneration>(
                    new GeneticGeneration(0)
                )
            );
        }
    }

    GeneticPopulation::GeneticPopulation(
        string fileName
    )
            : onGeneration(-1)
    {
        TiXmlDocument doc(fileName);

        bool loadStatus;

        if (iends_with(fileName,".gz"))
        {
            loadStatus = doc.LoadFileGZ();
        }
        else
        {
            loadStatus = doc.LoadFile();
        }

        if (!loadStatus)
        {
            throw CREATE_LOCATEDEXCEPTION_INFO("Error trying to load the XML file!");
        }

        TiXmlElement *root;

        root = doc.FirstChildElement();

        {
            TiXmlElement *generationElement = root->FirstChildElement("GeneticGeneration");

            while (generationElement)
            {
                if(generationElement->FirstChildElement("Individual") != NULL)
                    generations.push_back(shared_ptr<GeneticGeneration>(new GeneticGeneration(generationElement)));

                generationElement = generationElement->NextSiblingElement("GeneticGeneration");
                onGeneration++;
            }
        }

        if (onGeneration<0)
        {
            throw CREATE_LOCATEDEXCEPTION_INFO("Tried to load a population with no generations!");
        }

        if(Globals::getSingleton()->getParameterValue("MultiObjective", 0.0) < 0.5) {
            adjustFitness();
        }
    }

    GeneticPopulation::~GeneticPopulation()
    {
        while (!species.empty())
            species.erase(species.begin());

        while (!extinctSpecies.empty())
            extinctSpecies.erase(extinctSpecies.begin());
    }

    int GeneticPopulation::getIndividualCount(int generation)
    {
        if (generation==-1)
            generation=int(onGeneration);

        return generations[generation]->getIndividualCount();
    }

    void GeneticPopulation::addIndividual(shared_ptr<GeneticIndividual> individual)
    {
        generations[onGeneration]->addIndividual(individual);
    }

    shared_ptr<GeneticIndividual> GeneticPopulation::getIndividual(int a,int generation)
    {
        //cout << a << ',' << generation << endl;

        if (generation==-1)
        {
            //cout << "NO GEN GIVEN: USING onGeneration\n";
            generation=int(onGeneration);
        }

        if (generation>=int(generations.size())||a>=generations[generation]->getIndividualCount())
        {
            cout << "GET_INDIVIDUAL: GENERATION OUT OF RANGE!\n";
            throw CREATE_LOCATEDEXCEPTION_INFO("GET_INDIVIDUAL: GENERATION OUT OF RANGE!\n");
        }

        return generations[generation]->getIndividual(a);
    }

    vector<shared_ptr<GeneticIndividual> >::iterator GeneticPopulation::getIndividualIterator(int a,int generation)
    {
        if (generation==-1)
            generation=int(onGeneration);

        if (generation>=int(generations.size())||a>=generations[generation]->getIndividualCount())
        {
            throw CREATE_LOCATEDEXCEPTION_INFO("ERROR: Generation out of range!\n");
        }

        return generations[generation]->getIndividualIterator(a);
    }

    shared_ptr<GeneticIndividual> GeneticPopulation::getBestAllTimeIndividual()
    {
        shared_ptr<GeneticIndividual> bestIndividual;

        for (int a=0;a<(int)generations.size();a++)
        {
            for (int b=0;b<generations[a]->getIndividualCount();b++)
            {
                shared_ptr<GeneticIndividual> individual = generations[a]->getIndividual(b);
                if (bestIndividual==NULL||bestIndividual->getFitness()<=individual->getFitness())
                    bestIndividual = individual;
            }
        }

        return bestIndividual;
    }

    shared_ptr<GeneticIndividual> GeneticPopulation::getBestIndividualOfGeneration(int generation)
    {
        shared_ptr<GeneticIndividual> bestIndividual;

        if (generation==-1)
            generation = int(generations.size())-1;

        for (int b=0;b<generations[generation]->getIndividualCount();b++)
        {
            shared_ptr<GeneticIndividual> individual = generations[generation]->getIndividual(b);
            if (bestIndividual==NULL||bestIndividual->getFitness()<individual->getFitness())
                bestIndividual = individual;
        }

        return bestIndividual;
    }

    void GeneticPopulation::speciate()
    {
        double compatThreshold = Globals::getSingleton()->getParameterValue("CompatibilityThreshold");

        for (int a=0;a<generations[onGeneration]->getIndividualCount();a++)
        {
            shared_ptr<GeneticIndividual> individual = generations[onGeneration]->getIndividual(a);

            bool makeNewSpecies=true;

            for (int b=0;b<(int)species.size();b++)
            {
                double compatibility = species[b]->getBestIndividual()->getCompatibility(individual);
                if (compatibility<compatThreshold)
                {
                    //Found a compatible species
                    individual->setSpeciesID(species[b]->getID());
                    makeNewSpecies=false;
                    break;
                }
            }

            if (makeNewSpecies)
            {
                //Make a new species.  The process of making a new speceis sets the ID for the individual.
                shared_ptr<GeneticSpecies> newSpecies(new GeneticSpecies(individual));
                species.push_back(newSpecies);
            }
        }

        int speciesTarget = int(Globals::getSingleton()->getParameterValue("SpeciesSizeTarget"));

        double compatMod;

        if ((int)species.size()<speciesTarget)
        {
            compatMod = -Globals::getSingleton()->getParameterValue("CompatibilityModifier");
        }
        else if ((int)species.size()>speciesTarget)
        {
            compatMod = +Globals::getSingleton()->getParameterValue("CompatibilityModifier");
        }
        else
        {
            compatMod=0.0;
        }

        if (compatThreshold<(fabs(compatMod)+0.3)&&compatMod<0.0)
        {
            //This is to keep the compatibility threshold from going ridiculusly small.
            if (compatThreshold<0.001)
                compatThreshold = 0.001;

            compatThreshold/=2.0;
        }
        else if (compatThreshold<(compatMod+0.3))
        {
            compatThreshold*=2.0;
        }
        else
        {
            compatThreshold+=compatMod;
        }

        Globals::getSingleton()->setParameterValue("CompatibilityThreshold",compatThreshold);
    }

    void GeneticPopulation::setSpeciesMultipliers()
    {}

    void GeneticPopulation::adjustFitness()
    {
        if(Globals::getSingleton()->getParameterValue("MultiObjective", 0.0) > 0.5) {
            ifstream file("hello.gz", ios_base::in | ios_base::binary);
            boost::iostreams::filtering_streambuf<input> in;
            in.push(gzip_decompressor());
            in.push(file);
            boost::iostreams::copy(in, cout);



            if(Globals::getSingleton()->getParameterValue("GenotypicDiversity", 0.0) > 0.5) {

                for (int p=0;p<generations[onGeneration]->getIndividualCount();p++)
                {
                    shared_ptr<GeneticIndividual> individual1 = generations[onGeneration]->getIndividual(p);
                    vector<double> compatabilities;
                    for (int q=0;q<generations[onGeneration]->getIndividualCount();q++) {
                        if(p!=q) {
                            shared_ptr<GeneticIndividual> individual2 = generations[onGeneration]->getIndividual(q);
                            compatabilities.push_back(individual1->getCompatibility(individual2));
                        }
                    }
                    double compatabilitySum = 0;
                    //random_shuffle(compatabilities.begin(), compatabilities.end());
                    sort(compatabilities.begin(), compatabilities.end());
                    for(int i = 0; i<int(Globals::getSingleton()->getParameterValue("GenotypicDiversityK")) && i<compatabilities.size(); i++) {
                    //for(int i = 0; i<compatabilities.size(); i++) {
                    //	if(compatabilities[i] < Globals::getSingleton()->getParameterValue("CompatibilityThreshold"))
	                        compatabilitySum += compatabilities[i];
                    }

                    vector<double> fitnesses = individual1->getFitnesses();
                    //cout << fitnesses.size() << " ";
					int numFitnesses = int(Globals::getSingleton()->getParameterValue("NumFitnesses", 2.0));
                    if(fitnesses.size() < (numFitnesses + 1))
                        fitnesses.push_back(compatabilitySum);
                    else
                        fitnesses[numFitnesses] = compatabilitySum;
                    individual1->setFitnesses(fitnesses);
                }
                //cout << endl;
            }

            rankByDominance();
        } else {
            speciate();

            for (int a=0;a<(int)species.size();a++)
            {
                species[a]->resetIndividuals();
            }

            for (int a=0;a<generations[onGeneration]->getIndividualCount();a++)
            {
                shared_ptr<GeneticIndividual> individual = generations[onGeneration]->getIndividual(a);

                getSpecies(individual->getSpeciesID())->addIndividual(individual);
            }

            for (int a=0;a<(int)species.size();a++)
            {
                if (species[a]->getIndividualCount()==0)
                {
                    //extinctSpecies.push_back(species[a]);
                    species.erase(species.begin()+a);
                    a--;
                }
            }

            for (int a=0;a<(int)species.size();a++)
            {
                species[a]->setMultiplier();
                species[a]->setFitness();
                species[a]->incrementAge();
            }



            //This function sorts the individuals by fitness
            generations[onGeneration]->sortByFitness();
        }
    }

    void GeneticPopulation::produceNextGeneration()
    {
        if(Globals::getSingleton()->getParameterValue("MultiObjective") > 0.5) {
            produceNextGenerationMultiObjective();
            return;
        }

        cout << "In produce next generation loop...\n";
        //This clears the link history so future links with the same toNode and fromNode will have different IDs
        Globals::getSingleton()->clearLinkHistory();

        int numParents = int(generations[onGeneration]->getIndividualCount());

        for(int a=0;a<numParents;a++)
        {
            if(generations[onGeneration]->getIndividual(a)->getFitness() < 1e-6)
            {
                throw CREATE_LOCATEDEXCEPTION_INFO("ERROR: Fitness must be a positive number!\n");
            }
        }

        double totalFitness=0;

        for (int a=0;a<(int)species.size();a++)
        {
            totalFitness += species[a]->getAdjustedFitness();
        }
        int totalOffspring=0;
        for (int a=0;a<(int)species.size();a++)
        {
            double adjustedFitness = species[a]->getAdjustedFitness();
            int offspring = int(adjustedFitness/totalFitness*numParents);
            totalOffspring+=offspring;
            species[a]->setOffspringCount(offspring);
        }
        //cout << "Pausing\n";
        //system("PAUSE");
        //Some offspring were truncated.  Give these to the best individuals
        while (totalOffspring<numParents)
        {
            for (int a=0;totalOffspring<numParents&&a<generations[onGeneration]->getIndividualCount();a++)
            {
                shared_ptr<GeneticIndividual> ind = generations[onGeneration]->getIndividual(a);
                shared_ptr<GeneticSpecies> gs = getSpecies(ind->getSpeciesID());
                gs->setOffspringCount(gs->getOffspringCount()+1);
                totalOffspring++;

                /*
                //Try to give 2 offspring to the very best individual if it only has one offspring.
                //This fixes the problem where the best indiviudal sits in his own species
                //and duplicates every generation.
                if(a==0&&gs->getOffspringCount()==1&&totalOffspring<numParents)
                {
                gs->setOffspringCount(gs->getOffspringCount()+1);
                totalOffspring++;
                }*/

            }
        }
        for (int a=0;a<(int)species.size();a++)
        {
            cout << "Species ID: " << species[a]->getID() << " Age: " << species[a]->getAge() << " last improv. age: " << species[a]->getAgeOfLastImprovement() << " Fitness: " << species[a]->getFitness() << "*" << species[a]->getMultiplier() << "=" << species[a]->getAdjustedFitness() <<  " Size: " << int(species[a]->getIndividualCount()) << " Offspring: " << int(species[a]->getOffspringCount()) << endl;
        }

        //This is the new generation
        vector<shared_ptr<GeneticIndividual> > babies;

        double totalIndividualFitness=0;

        for (int a=0;a<(int)species.size();a++)
        {
            species[a]->setReproduced(false);
        }

        int smallestSpeciesSizeWithElitism
        = int(Globals::getSingleton()->getParameterValue("SmallestSpeciesSizeWithElitism"));
        double mutateSpeciesChampionProbability
        = Globals::getSingleton()->getParameterValue("MutateSpeciesChampionProbability");
        bool forceCopyGenerationChampion
        = (
              Globals::getSingleton()->getParameterValue("ForceCopyGenerationChampion")>
              Globals::getSingleton()->getRandom().getRandomDouble()
          );

        double bestFitness = 0;
        champOfHighestPerformingImprovedSpecies = shared_ptr<GeneticIndividual>();

        for (int a=0;a<generations[onGeneration]->getIndividualCount();a++)
        {
            //Go through and add the species champions
            shared_ptr<GeneticIndividual> ind = generations[onGeneration]->getIndividual(a);
            shared_ptr<GeneticSpecies> species = getSpecies(ind->getSpeciesID());
            if (!species->isReproduced())
            {
                species->setReproduced(true);
                //This is the first and best organism of this species to be added, so it's the species champion
                //of this generation
                if (ind->getFitness() > species->getBestIndividual()->getFitness())
                {
                    //We have a new all-time species champion!
                    species->setBestIndividual(ind);
                    cout << "Species " << species->getID() << " has a new champ with fitness " << species->getBestIndividual()->getFitness() << endl;

                    if(ind->getFitness() > bestFitness) {
                        bestFitness = ind->getFitness();
                        champOfHighestPerformingImprovedSpecies = ind;
                    }
                }

                if ((a==0&&forceCopyGenerationChampion)||(species->getOffspringCount()>=smallestSpeciesSizeWithElitism))
                {
                    //Copy species champion.
                    bool mutateChampion;
                    if (Globals::getSingleton()->getRandom().getRandomDouble()<mutateSpeciesChampionProbability)
                        mutateChampion = true;
                    else
                        mutateChampion = false;
                    babies.push_back(shared_ptr<GeneticIndividual>(new GeneticIndividual(ind,mutateChampion)));
                    species->decrementOffspringCount();
                }

                if (a==0)
                {
                    species->updateAgeOfLastImprovement();
                }
            }
            totalIndividualFitness+=ind->getFitness();
        }
        double averageFitness = totalIndividualFitness/generations[onGeneration]->getIndividualCount();
        cout<<"Generation "<<int(onGeneration)<<": "<<"overall_average = "<<averageFitness<<endl;
        cout << "Champion fitness: " << generations[onGeneration]->getIndividual(0)->getFitness() << endl;

        //if(int(generations[onGeneration]->getIndividual(0)->getFitness()) == 25) {
        //    cout << "Optimal solution found in generation " << onGeneration << endl;
        //    exit(0);
        //}

        if (generations[onGeneration]->getIndividual(0)->getUserData())
        {
            cout << "Champion data: " << generations[onGeneration]->getIndividual(0)->getUserData()->summaryToString() << endl;
        }
        cout << "# of Species: " << int(species.size()) << endl;
        cout << "compat threshold: " << Globals::getSingleton()->getParameterValue("CompatibilityThreshold") << endl;

        for (int a=0;a<(int)species.size();a++)
        {
            //cout << "Making babies\n";
            species[a]->makeBabies(babies);
        }

        if ((int)babies.size()!=generations[onGeneration]->getIndividualCount())
        {
            cout << "Population size changed!\n";
            throw CREATE_LOCATEDEXCEPTION_INFO("Population size changed!");
        }

        //cout << "Making new generation\n";
        shared_ptr<GeneticGeneration> newGeneration(generations[onGeneration]->produceNextGeneration(babies,onGeneration+1));
        //cout << "Done Making new generation!\n";

        /*for(int a=0;a<4;a++)
        {
        for(int b=0;b<4;b++)
        {
        cout << babies[a]->getCompatibility(babies[b]) << '\t';
        }

        cout << endl;
        }*/

        generations.push_back(newGeneration);
        onGeneration++;
    }


    void GeneticPopulation::produceNextGenerationMultiObjective() {
        cout << "In produce next generation (multi-objective) loop...\n";
        //This clears the link history so future links with the same toNode and fromNode will have different IDs
        Globals::getSingleton()->clearLinkHistory();



        vector<shared_ptr<GeneticIndividual> > parents;
        int size = (generations[onGeneration]->getIndividualCount()/2);
        int rank = 0;

        cout << ranks.size() << " " << size << endl << endl;
        //int sum = 0;
        //for(int i=0; i<ranks.size(); i++) {
        //    sum += ranks[i].size();
        //    cout << i << " " << ranks[i].size() << " " << sum << endl;
        //}


        while (parents.size() + ranks[rank].size() <=  size) {
            //cout << rank << " " << parents.size() << endl;
            calculateCrowdingDistances(ranks[rank]);
            parents.insert(parents.end(), ranks[rank].begin(), ranks[rank].end());
            rank += 1;
        }



        calculateCrowdingDistances(ranks[rank]);
        IndividualComparator comparator;
        sort(ranks[rank].begin(), ranks[rank].end(), comparator);
        int n = size - parents.size();
        parents.insert(parents.end(), ranks[rank].begin(), ranks[rank].begin() + n);


        for(int i=0; i<parents.size(); i++) {
            parents[i]->setCanReproduce(true);
        }



        vector<shared_ptr<GeneticIndividual> > babies;
        babies.insert(babies.end(), parents.begin(), parents.end());
        int offspringCount = size;

        double mutateOnlyProb = Globals::getSingleton()->getParameterValue("MutateOnlyProbability");

        cout << "making babies" << endl;

        for (int a=0;offspringCount>0;a++)
        {
            if (a>=1000000)
            {
                cout << "Error while making babies\n";
                exit(-1);
            }

            //if (Globals::getSingleton()->getRandom().getRandomDouble()<mutateOnlyProb)
            //{

            //binary tournament, asexual reproduction
                int choice1 = Globals::getSingleton()->getRandom().getRandomWithinRange(0,parents.size() - 1);
                int choice2 = Globals::getSingleton()->getRandom().getRandomWithinRange(0,parents.size() - 1);
                vector<shared_ptr<GeneticIndividual> > choices;
                choices.push_back(parents[choice1]);
                choices.push_back(parents[choice2]);
                sort(choices.begin(), choices.end(), comparator);

                babies.push_back(shared_ptr<GeneticIndividual>(new GeneticIndividual(choices[0],true)));
                offspringCount--;
            //}
            //else
            /*{
                shared_ptr<GeneticIndividual> parent1,parent2;
                int parentIndex = Globals::getSingleton()->getRandom().getRandomWithinRange(0,parents.size() - 1);
                parent1 = parents[parentIndex];

                int tt=0;
                do
                {
                    tt++;
                    if (tt==1000000)
                    {
                        cout << "Error while choosing parents.  Doing asexual reproduction\n";
                    }

                    int parentIndex = Globals::getSingleton()->getRandom().getRandomWithinRange(0,parents.size() - 1);
                    parent2 = parents[parentIndex];
                }
                while (parent2==parent1&&tt<=1000000);

                if (parent1==parent2)
                {
                    babies.push_back(shared_ptr<GeneticIndividual>(new GeneticIndividual(parent1,true)));
                }
                else
                {
                    babies.push_back(shared_ptr<GeneticIndividual>(new GeneticIndividual(parent1,parent2)));
                }
                offspringCount--;
            }*/
        }



        if ((int)babies.size()!=generations[onGeneration]->getIndividualCount())
        {
            cout << "Population size changed! Should be " << generations[onGeneration]->getIndividualCount() << ", but is " << (int)babies.size() << "\n";
            throw CREATE_LOCATEDEXCEPTION_INFO("Population size changed!");
        }

        cout<<"Generation "<<int(onGeneration)<<endl;
        shared_ptr<GeneticGeneration> newGeneration(generations[onGeneration]->produceNextGeneration(babies,onGeneration+1));
        generations.push_back(newGeneration);
        onGeneration++;


    }

    //double F_MAXES[2][2] = {{0, 50},{0, 0.5}};

    void GeneticPopulation::calculateCrowdingDistances(vector<shared_ptr<GeneticIndividual> > front) {
        if(front.size() == 0)
            return;

        for(int p = 0; p<front.size(); p++) {
            front[p]->setCrowdingDistance(0);
        }

        for(int m=0; m < front[0]->getFitnesses().size(); m++) {
            FitnessComparator comparator(m);
            sort(front.begin(),front.end(),comparator);
            front[0]->setCrowdingDistance(99999999);
            front[front.size() - 1]->setCrowdingDistance( 99999999 );
            for(int i=1; i< front.size() - 1; i++) {
                if(int(front[i]->getCrowdingDistance()) < 99999999) {
                    //front[i]->setCrowdingDistance( front[i]->getCrowdingDistance() + (front[i+1]->getFitnesses()[m] - front[i-1]->getFitnesses()[m])/(F_MAXES[m][1] - F_MAXES[m][0]));
                    front[i]->setCrowdingDistance( front[i]->getCrowdingDistance() + (front[i+1]->getFitnesses()[m] - front[i-1]->getFitnesses()[m])/(front[front.size() - 1]->getFitnesses()[m] - front[0]->getFitnesses()[m]));
                }
            }
        }

/*
        if(front.size() > 1) {
            for(int i = 0; i < front.size() - 1; i++) {
                bool equalFitnesses = true;
                for(int m=0;  m < front[i]->getFitnesses().size(); m++) {
                    int fitP = (int) (front[i]->getFitnesses()[m] * 1000000);
                    int fitQ = (int) (front[i+1]->getFitnesses()[m] * 1000000);
                    if(fitP != fitQ) {
                        equalFitnesses = false;
                        break;
                    }
                }

                if(equalFitnesses) {
                    front[i]->setCrowdingDistance(0);
                    front[i+1]->setCrowdingDistance(0);
                }
            }
        }
*/

    }

    void GeneticPopulation::rankByDominance()
    {
        vector<vector<int> > dominates;
        vector<int> dominationCount;
        vector<int> front;

        ranks.clear();

        vector<int> dominatesList;

        cout << "Ranking by dominance *******************************\n";
        int rank = 0;
        for(int i=0; i<1; i++) {
            vector<shared_ptr<GeneticIndividual> > tempRank;
            ranks.push_back(tempRank);
        }

        cout << "GEN: " << onGeneration << " ***************************" << endl;

        for (int p=0;p<generations[onGeneration]->getIndividualCount();p++)
        {

            //cout << p << " fit: " << generations[onGeneration]->getIndividual(p)->getFitness() << " fits: ";
            //cout << generations[onGeneration]->getIndividual(p)->getFitnesses()[0] << "," << generations[onGeneration]->getIndividual(p)->getFitnesses()[1] << endl;

            vector<int> temp;
            dominates.push_back(temp);
            dominationCount.push_back(0);

            bool nonDominated = true; //for purposes of Deciding who to back up


            for (int q=0;q<generations[onGeneration]->getIndividualCount();q++)
            {
                if( p != q) {
                    vector<double> fitnessesP = generations[onGeneration]->getIndividual(p)->getFitnesses();
                    vector<double> fitnessesQ = generations[onGeneration]->getIndividual(q)->getFitnesses();

                    if(Globals::getSingleton()->getParameterValue("GenotypicDiversity") > 0.5) {
                        bool pDominatesQ = true;
                        bool qDominatesP = true;
                        for(int i=0; i<(fitnessesP.size() - 1); i++)
                        {
                            long fitP, fitQ;
                            if( fabs(fitnessesP[i] - fitnessesQ[i]) < 2 && fitnessesP[i] < 1000 && fitnessesQ[i] < 1000) {
                                fitP = (long) (fitnessesP[i] * long(1000000));
                                fitQ = (long) (fitnessesQ[i] * long(1000000));
                            } else {
                                fitP = (long) fitnessesP[i];
                                fitQ = (long) fitnessesQ[i];
                            }
                            if(fitP > fitQ)
                                qDominatesP = false;
                            else if(fitQ > fitP)
                                pDominatesQ = false;
                        }
                        if((!pDominatesQ) && qDominatesP) {
                            nonDominated = false;
                        }
                    }

                    bool pDominatesQ = true;
                    bool qDominatesP = true;


                    for(int i=0; i<fitnessesP.size(); i++)
                    {
                        long fitP, fitQ;
                        if( fabs(fitnessesP[i] - fitnessesQ[i]) < 2 && fitnessesP[i] < 1000 && fitnessesQ[i] < 1000) {
                            fitP = (long) (fitnessesP[i] * long(1000000));
                            fitQ = (long) (fitnessesQ[i] * long(1000000));
                        } else {
                            fitP = (long) fitnessesP[i];
                            fitQ = (long) fitnessesQ[i];
                        }

                        //int fitP = (int) (fitnessesP[i] * 1000000);
                        //double fitP = fitnessesP[i];
                        //if( p == 124 )
                        //    cout << ">>>>>>>>>>>>>>>" << fitP << endl;
                        //int fitQ = (int) (fitnessesQ[i] * 1000000);
                        //double fitQ = fitnessesQ[i];
                        if(fitP > fitQ)
                            qDominatesP = false;
                        else if(fitQ > fitP)
                            pDominatesQ = false;
                    }
                    if(pDominatesQ) {
                        dominates[p].push_back(q);
                        if(q == 0) {
                        //    cout << "0 is dominated by " << p << " (" << fitnessesP[0] << "," << fitnessesP[1] << ") to (" << fitnessesQ[0] << "," << fitnessesQ[1] << ")"<< endl;
                        }
                    } else if(qDominatesP) {
                        dominationCount[p]++;
                        if(p == 0) {
                        //    cout << "0 is dominated by " << q << " (" << fitnessesQ[0] << "," << fitnessesQ[1] << ") to (" << fitnessesP[0] << "," << fitnessesP[1] << ")"<< endl;
                        }
                    }
                }
            }
            //dominatesList.push_back(dominationCount[p]);
            //cout << p << " " << dominationCount[p] << endl;

            //for(int i=0; i<dominates[p].size(); i++) {
            //    cout << dominates[p][i] << " ";
            //}
            //cout << endl;

            if(dominationCount[p] == 0) {
                generations[onGeneration]->getIndividual(p)->setRank(rank);
                ranks[0].push_back(generations[onGeneration]->getIndividual(p));
                front.push_back(p);
                if(Globals::getSingleton()->getParameterValue("GenotypicDiversity") > 0.5) {
                    if(nonDominated)
                        generations[onGeneration]->addNonDominated(generations[onGeneration]->getIndividual(p));
                } else {
                    generations[onGeneration]->addNonDominated(generations[onGeneration]->getIndividual(p));
                }
            }
        }


        //bool done = false;
        for(int j=0; j < 2; j++) {
            cout << "NONDOMINATED:";

            for(int i=0; i < front.size(); i++) {
                vector<double> fits = generations[onGeneration]->getIndividual(front[i])->getFitnesses();
                cout << " " << fits[j];
                //if(j == 0 && int(fits[0] * fits[1]) == 25)
                //    done = true;
            }
            cout << endl;
        }
        //if(done) {
        //    cout << "Optimal solution found in generation " << onGeneration << endl;
        //    exit(0);
        //}

        //sort(dominatesList.begin(), dominatesList.end());
        //for(int i=0; i<dominatesList.size(); i++) {
        //    cout << dominatesList[i] <<  " ";
        //}
        //cout << "\n***********************************\n";


        int sum = 0;
        while(front.size() > 0) {
            sum += ranks[rank].size();
            //cout << rank << " " << ranks[rank].size() << " " << sum << endl;
            rank++;
            vector<shared_ptr<GeneticIndividual> > tempRank;
            ranks.push_back(tempRank);
            vector<int> newFront;
            for (int i=0; i < front.size(); i++) {
                int p = front[i];
                for(int j = 0; j < dominates[p].size(); j++) {
                    int q = dominates[p][j];
                    dominationCount[q]--;
                    if(dominationCount[q] == 0) {
                        generations[onGeneration]->getIndividual(q)->setRank(rank);
                        ranks[rank].push_back(generations[onGeneration]->getIndividual(q));
                        newFront.push_back(q);
                    }
                }
            }
            //dominatesList.clear();
            //for (int p=0;p<generations[onGeneration]->getIndividualCount();p++) {
            //    dominatesList.push_back(dominationCount[p]);
            //    cout << dominationCount[p] <<  " ";
            //}
            //sort(dominatesList.begin(), dominatesList.end());
            //for(int i=0; i<dominatesList.size(); i++) {
            //    cout << dominatesList[i] <<  " ";
            //}
            //cout << "\n**********************************\n";




            front.clear();
            front = newFront;
        }
        sum += ranks[rank].size();
        cout << rank << " " << ranks[rank].size() << " " << sum << endl;
    }

    void GeneticPopulation::dump(string filename,bool includeGenes,bool doGZ)
    {

        cout << "dump -- filename: " << filename << " includeGenes: " << includeGenes << " doGZ: " << doGZ << endl;

        TiXmlDocument doc( filename );

        TiXmlElement *root = new TiXmlElement("Genetics");

        Globals::getSingleton()->dump(root);

        doc.LinkEndChild(root);

        for (int a=0;a<(int)generations.size();a++)
        {

            TiXmlElement *generationElementPtr = new TiXmlElement(generations[a]->getTypeName());

            root->LinkEndChild(generationElementPtr);

            generations[a]->dump(generationElementPtr,includeGenes);
        }

        if (doGZ)
        {
            doc.SaveFileGZ();
        }
        else
        {
            doc.SaveFile();
        }
    }

    void GeneticPopulation::dumpBest(string filename,bool includeGenes,bool doGZ)
    {
        cout << "dumpBest -- filename: " << filename << " includeGenes: " << includeGenes << " doGZ: " << doGZ << endl;

        if(Globals::getSingleton()->getParameterValue("MultiObjective") > 0.5 || NEAT::Globals::getSingleton()->getParameterValue("LargeOutput", 0.0) > 0.5) {
                stringstream ss;
                ss << (generations.size()-1);
                TiXmlDocument doc( filename + string("-") + ss.str() + string(".backup.xml") );
                if (generations.size())
                {

                    TiXmlElement *generationElementPtr = new TiXmlElement(generations[generations.size()-1]->getTypeName());
                    generations[generations.size()-1]->dumpBest(generationElementPtr,includeGenes);
                    doc.LinkEndChild(generationElementPtr);
                }

                if (doGZ)
                {
                    doc.SaveFileGZ();
                }
                else
                {
                    doc.SaveFile();
                }


            /*
            string existingFile = filename;
            if(doGZ)
            {
                existingFile = filename + ".gz";
            }

            ifstream *ifile = new ifstream(existingFile.c_str());
            if(ifile->good())
            {
                cout << "file exists!" << endl;
                TiXmlDocument doc( existingFile );

                bool loadStatus;

                if (doGZ)
                {
                    loadStatus = doc.LoadFileGZ();
                }
                else
                {
                    loadStatus = doc.LoadFile();
                }

                if (!loadStatus)
                {
                    throw CREATE_LOCATEDEXCEPTION_INFO("Error trying to load the XML file!");
                }


                TiXmlElement *root = doc.FirstChildElement();


                if (generations.size())
                {
                    //dump best guys from latest generation
                    TiXmlElement *generationElementPtr = new TiXmlElement(generations[generations.size()-1]->getTypeName());
                    generations[generations.size()-1]->dumpBest(generationElementPtr,includeGenes);
                    root->LinkEndChild(generationElementPtr);
                }

                if (doGZ)
                {
                    doc.SaveFileGZ(existingFile.c_str());
                }
                else
                {
                    doc.SaveFile();
                }
            }
            else
            {
                cout << "file does NOT exist!" << endl;

                TiXmlDocument doc( filename );

                TiXmlElement *root = new TiXmlElement("Genetics");

                Globals::getSingleton()->dump(root);

                doc.LinkEndChild(root);

                if (generations.size())
                {
                    //Always dump everyone from the final generation

                    //changing to only ever dump best

                    TiXmlElement *generationElementPtr = new TiXmlElement(generations[generations.size()-1]->getTypeName());
                    generations[generations.size()-1]->dumpBest(generationElementPtr,includeGenes);
                    root->LinkEndChild(generationElementPtr);
                }

                if (doGZ)
                {
                    doc.SaveFileGZ();
                }
                else
                {
                    doc.SaveFile();
                }
            }
            ifile->close();
            delete ifile;
            */
        } else {
            string existingFile = filename;
            if(doGZ)
            {
                existingFile = filename + ".gz";
            }

            ifstream *ifile = new ifstream(existingFile.c_str());
            if(ifile->good())
            {
                cout << "file exists!" << endl;
                TiXmlDocument doc( existingFile );

                bool loadStatus;

                if (doGZ)
                {
                    loadStatus = doc.LoadFileGZ();
                }
                else
                {
                    loadStatus = doc.LoadFile();
                }

                if (!loadStatus)
                {
                    throw CREATE_LOCATEDEXCEPTION_INFO("Error trying to load the XML file!");
                }


                TiXmlElement *root = doc.FirstChildElement();


                if (generations.size())
                {
                    //dump best guys from latest generation
                    TiXmlElement *generationElementPtr = new TiXmlElement(generations[generations.size()-1]->getTypeName());
                    generations[generations.size()-1]->dumpBest(generationElementPtr,includeGenes);
                    root->LinkEndChild(generationElementPtr);
                }

                if (doGZ)
                {
                    doc.SaveFileGZ(existingFile.c_str());
                }
                else
                {
                    doc.SaveFile();
                }
            }
            else
            {
                cout << "file does NOT exist!" << endl;

                TiXmlDocument doc( filename );

                TiXmlElement *root = new TiXmlElement("Genetics");

                Globals::getSingleton()->dump(root);

                doc.LinkEndChild(root);

                if (generations.size())
                {
                    //Always dump everyone from the final generation

                    //changing to only ever dump best

                    TiXmlElement *generationElementPtr = new TiXmlElement(generations[generations.size()-1]->getTypeName());
                    generations[generations.size()-1]->dumpBest(generationElementPtr,includeGenes);
                    root->LinkEndChild(generationElementPtr);
                }

                if (doGZ)
                {
                    doc.SaveFileGZ();
                }
                else
                {
                    doc.SaveFile();
                }
            }
            ifile->close();
            delete ifile;
/*
            TiXmlDocument doc( filename );

            TiXmlElement *root = new TiXmlElement("Genetics");

            Globals::getSingleton()->dump(root);

            doc.LinkEndChild(root);

            for (int a=0;a<int(generations.size())-1;a++)
            {

                TiXmlElement *generationElementPtr = new TiXmlElement(generations[a]->getTypeName());

                root->LinkEndChild(generationElementPtr);

                generations[a]->dumpBest(generationElementPtr,includeGenes);
            }

            if (generations.size())
            {
                //Always dump everyone from the final generation
                TiXmlElement *generationElementPtr = new TiXmlElement(generations[generations.size()-1]->getTypeName());
                generations[generations.size()-1]->dump(generationElementPtr,includeGenes);
                root->LinkEndChild(generationElementPtr);
            }

            if (doGZ)
            {
                doc.SaveFileGZ();
            }
            else
            {
                doc.SaveFile();
            }
*/

        }
    }

    void GeneticPopulation::cleanupOld(int generationSkip)
    {
        for (int a=0;a<onGeneration;a++)
        {
            if ( (a%generationSkip) == 0 )
                continue;

            generations[a]->cleanup();
        }
    }
}

